import { Injector } from '@angular/core';
import { HttpClient, HttpResponse, HttpEvent } from '@angular/common/http';
import { BehaviorSubject, Observable } from 'rxjs';
import { VerdocsTokenObjectService, VerdocsStateService } from '@verdocs/tokens';
import { ValidatorService } from '../validators/validator.service';
import { IEnvelopeSearchParams, DocumentSortOptions, IEnvelopeSearchResult } from '../models/document_search.model';
import { ITimePeriod } from '../models/time_period.model';
import { IDocument } from '../models/document.model';
import { IRecipient } from '../models/recipient.model';
export declare class DocumentsService {
    private httpClient;
    private validatorService;
    private tokenObjectService;
    private vTokenStateService;
    private injector;
    private platform;
    private _config_token;
    private _currentFields;
    private _currEnvelope;
    allEnvelopes: BehaviorSubject<IDocument[]>;
    _currentExtendedEnvelope: BehaviorSubject<any>;
    _customFilterSubject: BehaviorSubject<any>;
    currEnvelope$: Observable<string>;
    fieldsStream: Observable<any[]>;
    inProgressSubject: BehaviorSubject<boolean>;
    envelopeData: IDocument;
    private currEnvelope;
    private currRoleName;
    private _rForm_backend_url;
    private _documentUrl;
    private workingField;
    private envelope;
    validators: any;
    toggleNextSubject: BehaviorSubject<boolean>;
    constructor(httpClient: HttpClient, validatorService: ValidatorService, tokenObjectService: VerdocsTokenObjectService, vTokenStateService: VerdocsStateService, injector: Injector, platform: any);
    setCurrentEnvelope(id: any): void;
    setEnvData(envId: any, roleId: any): void;
    updateEnvelopes(envelopes: any): void;
    readonly role_name: string;
    readonly env_id: string;
    sendInvite(body: any): Observable<IDocument | never>;
    sendDelegate(envelopeId: any, role: any): Observable<IDocument | never>;
    resendInvitation(envelopeId: string, roleName: string): Observable<Object>;
    getEnvelope(id?: string): Observable<IDocument>;
    getAllEnvelopes(templateId?: string): Observable<import("@angular/common/http").HttpSentEvent | import("@angular/common/http").HttpHeaderResponse | import("@angular/common/http").HttpProgressEvent | HttpResponse<any> | import("@angular/common/http").HttpUserEvent<unknown>>;
    searchEnvelopes(searchParams: IEnvelopeSearchParams): Observable<HttpEvent<any> | IEnvelopeSearchResult>;
    getRecentActivities(page?: number): Observable<IEnvelopeSearchResult | import("@angular/common/http").HttpSentEvent | import("@angular/common/http").HttpHeaderResponse | import("@angular/common/http").HttpProgressEvent | HttpResponse<any> | import("@angular/common/http").HttpUserEvent<any>>;
    applyCustomSearch(filters: IEnvelopeSearchParams, searchParams: any): any;
    filterSearchBy(type: string, ascending?: boolean, row?: number, page?: number, filterTime?: ITimePeriod, sortBy?: DocumentSortOptions, customFilters?: IEnvelopeSearchParams): any;
    getWaitingOnOthers(ascending?: boolean, row?: number, page?: number, filterTime?: ITimePeriod, sortBy?: DocumentSortOptions, customFilters?: IEnvelopeSearchParams): any;
    getEnvelopeOwnerInfo(envId: string): Observable<Object>;
    getEnvelopeDocUrl(envId: string, docId: string): Observable<string>;
    getEnvelopePdfWithProgress(envelopeId: string, documentId: string): Observable<HttpEvent<unknown>>;
    getEnvelopeDocBlob(envId: string, docId: string): Observable<Blob>;
    getEnvelopeCertificateBlob(envId: string): Observable<Blob>;
    /********************************
     * Move logic to public library *
     *******************************/
    getTemplateDoc(templateId: string, token: string, file: boolean): Observable<any>;
    getTemplatePDF(templateId: string, token: string): Observable<HttpEvent<unknown>>;
    cancelEnvelope(id: string): Observable<Object>;
    submitEnvelope(envId: string, roleName: string): Observable<IRecipient>;
    declineEnvelope(envId: string, roleName: string): Observable<IRecipient>;
    uploadAttachment(envelopeId: any, file: File, fieldName: any): Observable<HttpEvent<unknown>>;
    downloadAttachment(field: any): Observable<Blob>;
    getAttachmentDataByRecipients(envelope: any): any[];
    /*****************
     * Signature API *
     ****************/
    postSignatureBlob(signatureBlob: Blob): Promise<any>;
    postInitialBlob(initialBlob: any): Promise<any>;
    putSignatureField(envelopeId: any, fieldName: any, signatureId: any): Promise<any>;
    putInitialField(envelopeId: any, fieldName: any, initialId: any): Promise<any>;
    putEnvelopeField(envelopeId: any, result: any): Promise<any>;
    updateGroupedField(envelopeId: any, body: any, fieldName: any, ifPrepared?: boolean): Promise<any>;
    private getPublicIp;
    /********************************
     * Move logic to public library *
     *******************************/
    sortRecipients(envelope: IDocument): IRecipient[];
    getRecipientColor(name: any, index?: any): string;
    validateEnvelopeField(): Promise<boolean>;
    private satisfyRequired;
    sortFields(fields: any): any;
    checkIfEnvelopeOwner(envelope: any): boolean;
    private canBeSameRow;
    private getHeight;
    hasCertificate(envelope: any): any;
}
